```toc
```
## What happens when a process terminates?

When a process terminates, the kernel does not remove it from the system immediately. Instead, the process is kept around in a terminated state until it is reaped by its parent. When the parent reaps the terminated child, the kernel passes the child's exit status to the parent and then discards the terminated process, at which point it ceases to exist. A terminated process that has not yet been reaped is called a zombie.

## Why is it important to reap child processes?

It is important to reap child processes because they consume system memory resources even though they are not running. Failure to reap zombie processes can lead to memory exhaustion and poor system performance.

## Handling of Orphaned and Zombie Processes in a System

### Kernel's Role in Handling Orphaned Processes

When a parent process terminates before its child processes, those children become "orphaned". To prevent these orphan processes from remaining indefinitely on the system, the kernel reassigns their parentage to the `init` process. The `init` process, with a Process ID (PID) of 1, is the first process spawned by the kernel during system start-up and continues to run until the system shuts down. It serves as the ultimate ancestor to all other processes.

### The `init` Process and Reaping of Zombie Processes

The `init` process has a vital role in the system of reaping zombie processes - these are the processes that have terminated but whose status has not yet been collected by their parent process. The `init` process periodically invokes the `wait()` or `waitpid()` system calls to check if any of its child processes have terminated. If a terminated child is found, these system calls retrieve the child's termination status, which allows the `init` process to remove its entry from the process table. This action, often referred to as "reaping", reclaims the resources that the terminated process was using and ensures the efficient utilization of system resources.

### Responsibility of `init` Process for Unreaped Zombies

In situations where a parent process exits without reaping its terminated children, those children become zombies. The kernel, to prevent resource exhaustion, assigns these zombie processes to the `init` process for reaping. By continuously monitoring its child processes, the `init` process plays a crucial role in cleaning up these zombie processes, ensuring that system resources are promptly released, and preventing the proliferation of zombies in the system.

### The `init` Process's Persistence in Reaping Terminated Processes

The `init` process employs a continuous loop to monitor its child processes. This loop, often running indefinitely, allows the `init` process to persistently check for terminated child processes. It uses `wait()` or `waitpid()` to check their status and reaps any terminated children it finds. The `init` process's enduring presence throughout the system's uptime ensures it is always available to prevent accumulation of zombie processes, thereby maintaining system stability and resource efficiency.
## Why should long-running programs reap their zombie children?

Long-running programs such as shells or servers should always reap their zombie children to prevent memory exhaustion and poor system performance.


## What is the waitpid function in Unix systems?

The `waitpid()` function is a system call used in Unix-based operating systems to wait for a child process to terminate and return its status. This function suspends the execution of the calling process until one of its child processes terminates.

### What does it mean that `waitpid` suspends execution of the calling process?

When the `waitpid` function is called by a parent process, it suspends or pauses the execution of the parent process until a child process in its "wait set" terminates. This means that the parent process is put into a waiting state and doesn't continue its execution until one of its child processes has completed its execution and terminated.

### What happens if a process in the wait set has already terminated?

If a process in the wait set has already terminated at the time of the call, `waitpid` returns immediately. In this case, `waitpid` provides the PID of the terminated child that caused it to return.

### What happens to a terminated child process when `waitpid` returns?

When `waitpid` returns, the terminated child process that caused the return has been "reaped", and the kernel removes all traces of it from the system. This is important as it helps free up system resources that were previously used by the child process.

### What is a "wait set"?

A "wait set" refers to the group of child processes that a parent process is waiting for. When a parent process calls `waitpid`, it specifies the PID of the child process it is waiting for. By passing a specific PID, the parent waits for a specific child. However, the parent can also wait for any of its child processes to terminate by passing a PID value of -1, meaning the wait set includes all of its children.


### What is the return value of waitpid?

The waitpid function returns the PID of the child that has terminated if it has successfully reaped a child process. The return value can also be 0 if the WNOHANG option is set and there are no child processes in the wait set that have terminated yet. If an error occurs, waitpid returns -1.

The status of the terminated child process is stored in the integer pointed to by the statusp parameter. This status contains information about the child's exit status and other termination-related information.

```c
            Parent Process                Child Process

                  |                             |
                  | fork()                      |
                  | -------------------------->|
                  |                             |
                  |                             |
                  |                             |
                  |          terminated         |
                  |<---------------------------|
                  |                             |
     waitpid()    |                             |
     returns      |                             |
     child's      |     status of child         |
     pid          |<----------------------------|
                  |                             |
```
In the example above, the parent process forks a child process. The child process runs and eventually terminates. The parent process calls `waitpid()` to wait for the child process to terminate and retrieve its exit status. Once the child process terminates, its status is passed to the parent process through the `statusp` parameter. At this point, the child process has been reaped and its resources have been released.

- - -
## How are the members of the wait set determined in waitpid?

The members of the wait set are determined by the `pid` argument passed to `waitpid()`. The `pid` argument can take on three values:

1.  If `pid > 0`, then the wait set is the singleton child process whose process ID is equal to `pid`.
    
2.  If `pid = -1`, then the wait set consists of all of the parent's child processes.
    
3.  If `pid = 0`, then the wait set consists of all child processes whose process group ID is equal to that of the calling process.
    
4.  If `pid < -1`, then the wait set consists of all child processes whose process group ID is equal to the absolute value of `pid`.

## Process group ID
#### What is a process group in Unix-based operating systems?

A process group is a collection of one or more processes that are associated with a unique identifier called a process group ID (PGID). It allows related processes to be grouped together.

### What is the purpose of a process group ID (PGID)?

The PGID is used to group related processes together. It serves as a unique identifier for a process group, allowing signals sent to the group to be received by all of its members.

### What is the leader of a process group?

Each process group has a leader, which is the first process in the group. The leader's process ID (PID) is used as the process group ID (PGID) for the group. The leader has special significance and additional responsibilities within the group.

These responsibilities include:

1.  Receiving Signals: The leader process is responsible for receiving signals sent to the entire process group. When a signal is sent to the PGID of the process group, the leader process receives the signal first and can choose to handle or propagate it to other processes in the group.
    
2.  Process Termination: If the leader process terminates, the operating system assigns a new leader to the process group. This ensures that there is always a designated leader responsible for the process group.
    
3.  Controlling Process Group Attributes: The leader process has the ability to modify certain process group attributes, such as changing the foreground or background status of the group, modifying the process group ID, or creating new process groups within the same session.
    
4.  Session Leader: In addition to being a process group leader, the leader of the initial process group within a session is also designated as the session leader. The session leader has additional responsibilities related to session control and can manage session-wide operations.
    

It's important to note that these additional responsibilities are specific to the leader process within a process group and are not shared by other processes within the group.

### How can a process join a process group?

A process can join a process group by calling the `setpgid()` system call, which sets its PGID to the same value as the leader's PID of the desired process group. By doing so, the process becomes a member of the specified process group.

### Why is the concept of process groups important?

Process groups are important for managing sets of related processes. By grouping related processes into a single process group, they can be managed together as a unit. This allows for easier signaling, monitoring, and termination of the group as a whole. Process groups are commonly used in scenarios such as managing processes spawned by a shell script or coordinating processes in high-level programs.

### What happens if `pid > 0`?

If `pid` is greater than 0, the wait set consists of a single child process whose process ID is equal to `pid`. This means that the calling process will wait only for the child process specified by `pid` to terminate, and will not wait for any other child processes that may exist.

For example, if a parent process has created several child processes and wants to wait for a specific child process to terminate, it can use the `waitpid` function with a `pid` argument greater than 0 to wait for that specific child process. In this case, the `waitpid` function will block the parent process until the specified child process terminates, and return the process ID of the terminated child process.

Here's a simple example in Python that demonstrates the behavior of `waitpid` with `pid > 0`:
```c
import os
import sys
import time
from ctypes import *

# Create a child process
pid = os.fork()

if pid == 0:
    # Child process
    print("Child process running")
    time.sleep(2)
    print("Child process terminating")
    sys.exit(0)

# Parent process
print(f"Parent process waiting for child {pid} to terminate")
status = c_int(0)
child_pid = os.waitpid(pid, byref(status), 0)

print(f"Child process {child_pid} has terminated with status {status.value}")
```
In this example, the parent process creates a child process using the `fork()` system call, and waits for it to terminate using the `waitpid()` function with `pid > 0`. The child process waits for 2 seconds and then terminates with an exit status of 0. When the child process terminates, the parent process prints a message indicating that the child process has terminated with the exit status returned by the `waitpid()` function.

Since the `pid` argument is greater than 0, `waitpid()` waits only for the specific child process with process ID `pid` to terminate, and does not wait for any other child processes that may exist.


### What happens if `pid = -1`?

In the context of the `waitpid` function in Unix-like operating systems, if the `pid` argument is `-1`, it specifies that the calling process should wait for any child process to terminate, regardless of its process ID. In other words, the wait set consists of all of the parent's child processes.

When the `pid` argument is `-1`, the `waitpid` function will block the calling process until any one of the parent's child processes terminates, and will return the process ID of the terminated child process. This behavior is useful when the parent process needs to wait for any one of its child processes to terminate, regardless of which one.

For example, if a parent process has created several child processes and needs to wait for any one of them to terminate, it can use the `waitpid` function with a `pid` argument of `-1`. When one of the child processes terminates, the `waitpid` function will return the process ID of the terminated child process to the parent process.

Here's an example in Python that demonstrates the behavior of `waitpid` with `pid = -1`:
```c
import os
import sys
import time
from ctypes import *

# Create three child processes
for i in range(3):
    pid = os.fork()

    if pid == 0:
        # Child process
        print(f"Child process {os.getpid()} running")
        time.sleep(i + 1)
        print(f"Child process {os.getpid()} terminating")
        sys.exit(0)

# Parent process
print("Parent process waiting for any child process to terminate")
status = c_int(0)
child_pid = os.waitpid(-1, byref(status), 0)

print(f"Child process {child_pid} has terminated with status {status.value}")
```
In this example, the parent process creates three child processes using the `fork()` system call. Each child process waits for a different amount of time before terminating. The parent process waits for any one of the child processes to terminate using the `waitpid()` function with a `pid` argument of `-1`. When one of the child processes terminates, the `waitpid()` function returns the process ID of the terminated child process to the parent process.

### What happens if `pid = 0`?
if the `pid` argument is `0`, it specifies that the calling process should wait for any child process in the same process group to terminate. In other words, the wait set consists of all child processes whose process group ID is equal to that of the calling process.

When the `pid` argument is `0`, the `waitpid` function will block the calling process until any one of the child processes in the same process group terminates, and will return the process ID of the terminated child process. This behavior is useful when the parent process needs to wait for any child process in the same process group to terminate.

For example, if a parent process has created several child processes in the same process group and needs to wait for any one of them to terminate, it can use the `waitpid` function with a `pid` argument of `0`. When one of the child processes terminates, the `waitpid` function will return the process ID of the terminated child process to the parent process.

Here's an example in Python that demonstrates the behavior of `waitpid` with `pid = 0`:
```c
import os
import sys
import time
from ctypes import *

# Create three child processes
for i in range(3):
    pid = os.fork()

    if pid == 0:
        # Child process
        print(f"Child process {os.getpid()} running")
        time.sleep(i + 1)
        print(f"Child process {os.getpid()} terminating")
        sys.exit(0)

# Parent process
print("Parent process waiting for any child process to terminate")
status = c_int(0)
child_pid = os.waitpid(-1, byref(status), 0)

print(f"Child process {child_pid} has terminated with status {status.value}")
```
In this example, the parent process creates three child processes using the `fork()` system call. Each child process waits for a different amount of time before terminating. The parent process waits for any one of the child processes to terminate using the `waitpid()` function with a `pid` argument of `-1`. When one of the child processes terminates, the `waitpid()` function returns the process ID of the terminated child process to the parent process.

Here's an example in C that demonstrates how to use `waitpid()` with a negative `pid` argument to wait for child processes in a specific process group:
```c
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    pid_t pid;
    int status;

    // Create a new process group for the child processes
    setpgid(0, 0);

    // Launch several child processes
    for (int i = 0; i < 3; i++) {
        pid = fork();
        if (pid < 0) {
            perror("fork");
            exit(1);
        } else if (pid == 0) {
            // Child process: simulate some work
            sleep(i+1);
            printf("Child %d finished\n", i+1);
            exit(0);
        }
    }

    // Wait for all child processes to finish
    pid = -getpid(); // use negative value to wait for process group
    while (1) {
        pid_t result = waitpid(pid, &status, WNOHANG);
        if (result == -1) {
            perror("waitpid");
            exit(1);
        } else if (result == 0) {
            // No child has exited yet, do something else while waiting
            printf("Waiting for child processes...\n");
            sleep(1);
        } else {
            // A child has exited, check its status and continue waiting
            if (WIFEXITED(status)) {
                printf("Child %d exited with status %d\n", result, WEXITSTATUS(status));
            } else if (WIFSIGNALED(status)) {
                printf("Child %d terminated by signal %d\n", result, WTERMSIG(status));
            } else if (WIFSTOPPED(status)) {
                printf("Child %d stopped by signal %d\n", result, WSTOPSIG(status));
            } else if (WIFCONTINUED(status)) {
                printf("Child %d resumed by SIGCONT\n", result);
            }
            if (--i == 0) {
                // All child processes have exited, break out of the loop
                break;
            }
        }
    }

    printf("All child processes have finished\n");
    return 0;
}
```
In this example, we use the `setpgid()` function to create a new process group for the child processes. We then launch three child processes using `fork()`, each of which simulates some work by sleeping for a different number of seconds.

To wait for all child processes to finish, we use a `while` loop that calls `waitpid()` with a negative `pid` argument equal to the PID of the parent process's process group (which is obtained by negating the parent process's PID using `-getpid()`). We use the `WNOHANG` option to return immediately if no child has exited yet, and we print a message to indicate that we are still waiting.

When a child process exits, `waitpid()` returns its PID, and we print its status using the `WIFEXITED`, `WIFSIGNALED`, `WIFSTOPPED`, and `WIFCONTINUED` macros. We then decrement the counter `i` that keeps track of the number of remaining child processes, and continue waiting until all child processes have exited.

Once all child processes have finished, we print a message to indicate that we are done.

### What happens if `pid < -1`?
If `pid < -1`, the `waitpid()` function call will wait for the termination of any child process whose process group ID is equal to the absolute value of `pid`. This means that the wait set consists of all child processes that belong to the same process group as the process whose PID is equal to the absolute value of `pid`.

For example, if the calling process has a PID of 1000 and there are several child processes that belong to the same process group with PGID 2000, we can use `waitpid()` with a `pid` argument of `-2000` to wait for any of those child processes to terminate.

This can be useful when we want to wait for a group of related child processes to complete their work before continuing with the execution of the parent process. For example, we may have a parent process that launches several child processes to perform parallel computations, and we want to wait for all of them to complete before gathering their results and returning the final output to the user.

By placing the child processes into a separate process group, we can use `waitpid()` with a negative `pid` value to wait for all of them to finish, regardless of the order in which they terminate. This can simplify the synchronization and coordination of the child processes, making it easier to write reliable and efficient parallel programs.

### What are the options to modify the default behavior of the `waitpid` function?

The default behavior of the `waitpid` function can be modified by setting options to various combinations of the `WNOHANG`, `WUNTRACED`, and `WCONTINUED` constants.

### How can the default behavior of waitpid be modified?

The default behavior of `waitpid()` can be modified by setting options to various combinations of the `WNOHANG`, `WUNTRACED`, and `WCONTINUED` constants.

1.  `WNOHANG`: Return immediately (with a return value of 0) if none of the child processes in the wait set has terminated yet. The default behavior suspends the calling process until a child terminates; this option is useful in those cases where you want to continue doing useful work while waiting for a child to terminate.
    
2.  `WUNTRACED`: Suspend execution of the calling process until a process in the wait set becomes either terminated or stopped. Return the PID of the terminated or stopped child that caused the return. The default behavior returns only for terminated children; this option is useful when you want to check for both terminated and stopped children.
    
3.  `WCONTINUED`: Suspend execution of the calling process until a running process in the wait set is terminated or until a stopped process in the wait set has been resumed by the receipt of a `SIGCONT` signal.
    

You can combine options by OR-ing them together. For example, `WNOHANG | WUNTRACED` will return immediately, with a return value of 0, if none of the children in the wait set has stopped or terminated, or with a return value equal to the PID of one of the stopped or terminated children.

Here is an example of using options with `waitpid()`:
```c
pid_t pid;
int status;
pid = fork();

if (pid == 0) {
    /* child process code */
} else if (pid > 0) {
    /* parent process code */
    waitpid(pid, &status, WNOHANG | WUNTRACED);  // parent waits for child to terminate or stop
} else {
    /* error occurred during fork */
}
```

### How can options be combined in the `waitpid` function?

Options can be combined by oring them together. For example, `WNOHANG | WUNTRACED` will return immediately with a return value of 0 if none of the children in the wait set have stopped or terminated, or with a return value equal to the PID of one of the stopped or terminated children.

## Checking the Exit Status of a Reaped Child 
### What is the purpose of checking the exit status of a reaped child?

When a child process is terminated, its parent process can wait for the child to terminate and obtain information about the exit status of the child. The exit status is a value that the child process passes to the parent process to indicate whether it has completed successfully or not. Checking the exit status of a reaped child can help the parent process to determine whether the child has terminated successfully or not and take appropriate action accordingly.

### How can the status information of a reaped child be obtained using waitpid?

The status information about the child that caused the return in status can be obtained using waitpid system call. If the statusp argument is non-NULL, then waitpid encodes status information about the child that caused the return in status, which is the value pointed to by statusp.
```c
pid_t waitpid(pid_t pid, int *statusp, int options);
```
### What are the different macros defined in wait.h for interpreting the status argument?

The wait.h include file defines several macros for interpreting the status argument:

-   `WIFEXITED(status)`: Returns true if the child terminated normally, via a call to `exit` or a return.
    
-   `WEXITSTATUS(status)`: Returns the exit status of a normally terminated child. This status is only defined if `WIFEXITED()` returned true.
    
-   `WIFSIGNALED(status)`: Returns true if the child process terminated because of a signal that was not caught.
    
-   `WTERMSIG(status)`: Returns the number of the signal that caused the child process to terminate. This status is only defined if `WIFSIGNALED()` returned true.
    
-   `WIFSTOPPED(status)`: Returns true if the child that caused the return is currently stopped.
    
-   `WSTOPSIG(status)`: Returns the number of the signal that caused the child to stop. This status is only defined if `WIFSTOPPED()` returned true.
    
-   `WIFCONTINUED(status)`: Returns true if the child process was restarted by receipt of a `SIGCONT` signal.
    

### Why is it important to use these macros for interpreting the status argument?

Using these macros to interpret the status argument can make it easier for the parent process to determine what happened to the child process and take appropriate action. For example, if `WIFEXITED()` returns true, then the child process terminated normally, and the exit status can be obtained using `WEXITSTATUS()`. If `WIFSIGNALED()` returns true, then the child process terminated because of a signal that was not caught, and the signal number can be obtained using `WTERMSIG()`. If `WIFSTOPPED()` returns true, then the child process is currently stopped, and the signal number that caused the child to stop can be obtained using `WSTOPSIG()`. By using these macros, the parent process can handle the different cases appropriately.

### Practice Problem 8.3
List all of the possible output sequences for the following program:

------------------------------------------------------------------------------------------------------_code/ecf/waitprob0.c_

```c

1	int main()
2	{
3		if (Fork() == 0) {
4			printf("a"); fflush(stdout);
5		}
6		else {
7			printf("b"); fflush(stdout);
8			waitpid(-1, NULL, 0);
9		}
10		printf("c"); fflush(stdout);
11		exit(0);
12	}
```
Book answer: We know that the sequences acbc, abcc, and bacc are possible because they correspond to topological sorts of the process graph (Figure 8.48). However, sequences such as bcac and cbca do not correspond to any topological sort and thus are not feasib

GPT: 
Here are all the possible output sequences for the given program:

1.  "abc" - The parent process executes first, printing "b" and then waiting for the child process to terminate. The child process then executes and prints "a", followed by the parent process printing "c".
2.  "bac" - The child process executes first, printing "a". The parent process then executes and prints "b" before waiting for the child process to terminate. Once the child process terminates, the parent process prints "c".
3.  "bca" - The parent process executes first, printing "b" and then immediately printing "c". The child process then executes and prints "a".

Note that the output order is nondeterministic, meaning that any of the above sequences could occur, and the actual sequence observed is dependent on the system and scheduling.

The possible output sequences are determined by the order in which the processes execute. In this program, there are two processes: the parent and the child. The parent prints "b" and waits for the child to finish before printing "c" and exiting. The child just prints "a" and exits.

The possible output sequences are determined by the order in which the processes execute. The order in which the processes execute is determined by the scheduler and is nondeterministic. However, we can draw a process graph to visualize the possible orderings.

The process graph for this program has three nodes: a, b, and c. The edge from a to c indicates that process c must run after process a has finished. The edge from b to c indicates that process c must run after process b has finished. The edges from the start node to a and b indicate that processes a and b can start at any time.

The topological sorts of this graph correspond to the possible output sequences of the program. A topological sort is an ordering of the nodes such that all edges point in the same direction. For example, the topological sort abc corresponds to the sequence abcc, which is a possible output of the program. Similarly, the topological sorts acb and bac correspond to the sequences acbc and bacc, respectively, which are also possible outputs.

However, not all sequences are possible. For example, the sequence bcac cannot occur because process c must run after process a has finished. If process a finishes before process b starts, then process c cannot run between them. Similarly, the sequence cbca cannot occur because process c must run after process b has finished. If process b finishes before process a starts, then process c cannot run between them.
Example process graph:
```c
             main()
               |
          +----+----+
          |         |
          v         v
         Fork()    printf("c")
          |         |
     +----+----+    |
     |         |    |
     v         v    |
  printf("a")  exit(0)

This process graph shows that the main process forks a child process and then prints "c" while waiting for the child to terminate. The child process prints "a" and then terminates by calling `exit(0)`. The arrows indicate the order in which the processes execute.
```
### Using the waitpid function to reap zombie children in no particular order.
```c
1 #include "csapp.h" // Include the header file for the CSAPP library
2 #define N 2 // Define a constant N with a value of 2
3 
4 int main() { // Define the main function
5     int status, i; // Declare two integer variables to be used later
6     pid_t pid; // Declare a process ID variable to be used later
7     
8     /* Parent creates N children */
9     for (i = 0; i < N; i++) { // Iterate over N times to create N child processes
10         if ((pid = Fork()) == 0) // If we're in the child process (Fork() returns 0 for the child)
11             exit(100+i); // Exit the child process with status 100+i
12     }
13     
14     /* Parent reaps N children in no particular order */
15     while ((pid = waitpid(-1, &status, 0)) > 0) { // Wait for any child process to exit
16         if (WIFEXITED(status)) // Check if child process exited normally
17             printf("child %d terminated normally with exit status=%d\n", // Print exit status of child process
18                     pid, WEXITSTATUS(status));
19         else
20             printf("child %d terminated abnormally\n", pid); // Print if child process exited abnormally
21     }
22     
23     /* The only normal termination is if there are no more children */
24     if (errno != ECHILD) // Check if there was an error reaping children
25         unix_error("waitpid error"); // Print an error message and terminate the program
26     
27     exit(0); // Exit the program with status 0
28 }
```
In the given code, line 12 is executed by each child because it is inside the condition that checks if the process ID returned by `fork()` is zero, which means the current process is the child process. Thus, each child executes the exit function and terminates with a unique exit status.

Moving on to line 15, the parent process waits for all of its children to terminate by using the `waitpid` function with a loop that iterates until all children have been reaped. Since the first argument to `waitpid` is -1, it waits for any child to terminate and returns the process ID of the terminated child. As each child terminates, the parent extracts the exit status of that child using `WEXITSTATUS` and prints it on stdout.

After all the children have been reaped, the next call to `waitpid` returns -1 and sets errno to `ECHILD`. To handle this case, line 24 checks if the `errno` value is not `ECHILD`, which indicates an error has occurred while waiting for the children, and prints an error message.

When the program is executed, it reaps its children in a nondeterministic order, as the order in which the children are reaped is a property of the specific computer system. It is possible that on another system or even on the same system, the order of the reaped children may be different. Therefore, this is an example of the nondeterministic behavior that makes reasoning about concurrency difficult. It is important to note that both possible outcomes are equally correct, and as a programmer, you should not assume that one outcome will always occur. Instead, you should assume that each possible outcome is equally likely.

### Practice Problem 8.4
Consider the following program:

------------------------------------------------------------------------------------------------------_code/ecf/waitprob1.c_

```c

1	int main()
2	{
3		int status;
4		pid_t pid;
5	
6		printf("Hello\n");
7		pid = Fork();
8		printf("%d\n", !pid);
9		if (pid != 0) {
10			if (waitpid(-1, &status, 0) > 0) {
11				if (WIFEXITED(status) != 0)
12					printf("%d\n", WEXITSTATUS(status));
13				}
14		}
15		printf("Bye\n");
16		exit(2);
17	}
```

------------------------------------------------------------------------------------------------------_code/ecf/waitprob1.c_

1.  How many output lines does this program generate?
    
2.  What is one possible ordering of these output lines?

1) Book ans:"We can determine the number of lines of output by simply counting the number of printf vertices in the process graph (Figure 8.49). In this case, there are six such vertices, and thus the program will print six lines of output."

GPT: 
The solution may have counted the number of "printf vertices" in the process graph, which includes not only the actual printf statements in the code, but also any implicit ones caused by the execution of other statements (such as the call to exit, which typically prints a message indicating the program's exit status). Therefore, the solution may have counted the following six "printf vertices" in the process graph:

1.  The first line printed is "Hello", which is printed by the parent process before it forks a child process.
2.  The second line printed depends on the return value of the Fork() function. If the function returns 0, then the child process prints "1", because the logical negation of 0 is 1. If the function returns a nonzero value, then the parent process prints "0", because the logical negation of any nonzero value is 0.
3.  The third line printed depends on whether the current process is the parent or the child. If the process is the parent, it waits for the child to terminate by calling waitpid(). When the child terminates, its exit status is returned in the "status" variable. If the child process exits normally, its exit status is printed on a new line. The exit status is an integer value that is passed to the exit() function when the child process terminates.
4.  The fourth line printed is "Bye", which is printed by the parent process after the child process has terminated.
5.  The fifth line printed is the exit status of the process, which is passed to the exit() function at the end of main(). This value can be any integer, but in this case it is hardcoded to 2.
6.  The final line printed is "Bye", which is printed by the parent process before it terminates.

Thus, the program generates a total of six lines of output, with the third line (the exit status of the child process) being optional depending on the behavior of the child proces

However, it's worth noting that some of these "printf vertices" may not actually produce visible output (such as the exit status message and the shell prompt), so the actual number of visible output lines may be different. In any case, if we only count the explicit printf statements in the code, there are indeed only four of them, as you pointed out.

There are a total of six `printf` statements. To understand this, let's analyze the process graph.

When the program starts, the `main` process is created, and it executes the first `printf` statement, which prints "Hello". After that, the process forks, creating a child process. At this point, the process graph looks like this:
```c
           main
             |
         printf("Hello")
             |
            fork
            /   \
        main   child
```

The parent process executes the second `printf` statement, which prints the result of the expression `!pid`. Since `pid` is nonzero in the parent process, `!pid` is 0, so the parent process prints 0. The child process skips this statement and continues with its execution. The process graph now looks like this:
```c
            main
              |
          printf("Hello")
              |
             fork
            /   \
        main     child
          |
     printf("0")
```
Now, the parent process waits for the child to terminate by calling `waitpid`. This call blocks until the child process terminates. When the child process terminates, the parent process retrieves the exit status of the child by calling `WIFEXITED` and `WEXITSTATUS`. If the child process terminated normally, the exit status will be nonzero, and the parent process will execute the fourth `printf` statement. This statement prints the exit status of the child process. The process graph now looks like this:
```c
           main
             |
         printf("Hello")
             |
            fork
            /   \
        main   child
          |      |
    printf("0") exit
               |
        printf(exit status)
```
After printing the exit status, the parent process executes the final `printf` statement, which prints "Bye". Finally, both the parent and child processes exit. The process graph now looks like this:
```c
           main
             |
         printf("Hello")
             |
            fork
            /   \
        main   child
          |      |
    printf("0") exit
               |
        printf(exit status)
               |
         printf("Bye")
```

2) 
book ans: 
Any output sequence corresponding to a topological sort of the graph is possible. For example: `Hello, 1,0, Bye, 2, Bye` is possible.

GPT:

The program begins by printing "Hello". Then it forks a child process, and the parent prints "1" while the child prints "0". Since the parent process waits for the child process to complete before continuing, the next line of output could be either "Bye" or the child's exit status, depending on which process completes first. Let's assume that the child completes first and exits with a status of 2. Then the parent prints "Bye", followed by its own exit status of 2. Therefore, the output sequence would be:

Hello, 1, 0, Bye, 2, Bye

This output sequence is possible because it corresponds to a valid topological sort of the process graph. The graph has six vertices (one for each call to `printf`), and any topological sort of a graph with `n` vertices will produce an output sequence with `n` lines of output. In this case, the graph has the following structure:

```c
Hello -> pid -> !pid -> waitpid -> WIFEXITED -> printf(WEXITSTATUS) -> Bye
          |       |        |            |                    |
          v       v        v            v                    v
           1       0       Bye           |                    |
                                        v                    v
                                        2                    2
```
A valid topological sort of this graph would be to start with "Hello", then choose either "1" or "0" (since those two vertices are independent and can be scheduled in any order), then choose "Bye", then choose the exit status, and finally choose "Bye" again. This gives us the output sequence "Hello, 1, 0, Bye, 2, Bye".

### Using `waitpid` to reap zombie children in the order they were created.
```c
#include "csapp.h"  // includes necessary header files

#define N 2  // number of child processes to create

int main()
{
    int status, i;
    pid_t pid[N], retpid;

    /* Parent creates N children */
    for (i = 0; i < N; i++) {
        if ((pid[i] = Fork()) == 0) /* Child */
            exit(100+i); // child process terminates with exit status 100+i
    }

    /* Parent reaps N children in order */
    i = 0;
    while ((retpid = waitpid(pid[i++], &status, 0)) > 0) { // loop over all child processes
        if (WIFEXITED(status)) { // check if child terminated normally
            printf("child %d terminated normally with exit status=%d\n",
                retpid, WEXITSTATUS(status)); // print the child's pid and exit status
        } else {
            printf("child %d terminated abnormally\n", retpid); // print the child's pid and indicate abnormal termination
        }
    }

    /* The only normal termination is if there are no more children */
    if (errno != ECHILD) // check if there are still child processes that haven't been reaped
        unix_error("waitpid error"); // print error message

    exit(0); // parent process terminates
}
```
In summary, this program creates `N` child processes using a loop, and each child process terminates with an exit status of `100+i`, where `i` is the index of the child process. The parent process then waits for each child process to terminate using `waitpid` in a loop. The loop continues until all child processes have been reaped. During each iteration of the loop, the parent process prints information about the child process that just terminated, including the child's PID and exit status. Finally, the program checks if there are any unreaped child processes and prints an error message if there are. The parent process terminates with an exit status of 0.
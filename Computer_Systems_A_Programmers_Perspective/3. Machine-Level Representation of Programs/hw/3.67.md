For this exercise, we will examine the code generated by gcc for functions that have structures as arguments and return values, and from this see how these language features are typically implemented.

The following C code has a function process having structures as argument and return values, and a function eval that calls process:

```c

1	typedef struct {
2		long a[2];
3		long *p;
4	} strA;
5	
6	typedef struct {
7		long u[2];
8		long q;
9	} strB;
10	
11	strB process(strA s) {
12		strB r;
13		r.u[0] = s.a[1];
14		r.u[1] = s.a[0];
15		r.q = *s.p;
16		return r;
17	}
18	
19	long eval(long x, long y, long z) {
20		strA s;
21		s.a[0] = x;
22		s.a[1] = y;
23		s.p = &z;
24		strB r = process(s);
25		return r.u[0] + r.u[1] + r.q;
26	}
```

Gcc generates the following code for these two functions:

```c

	strB process(strA s)
1	process:
2	  movq	%rdi, %rax
3	  movq	24(%rsp), %rdx
4	  movq	(%rdx), %rdx
5	  movq	16(%rsp), %rcx
6	  movq	%rcx, (%rdi)
7	  movq	8(%rsp), %rcx
8	  movq	%rcx, 8(%rdi)
9	  movq	%rdx, 16(%rdi)
10	  ret
	long eval(long x, long y, long z)
	x in %rdi, y in %rsi, z in %rdx
1	eval:
2	  subq	$104, %rsp
3	  movq	%rdx, 24(%rsp)
4	  leaq	24(%rsp), %rax
5	  movq	%rdi, (%rsp)
6	  movq	%rsi, 8(%rsp)
7	  movq	%rax, 16(%rsp)
8	  leaq	64(%rsp), %rdi
9	  call	process
10	  movq	72(%rsp), %rax
11	  addq	64(%rsp), %rax
12	  addq	80(%rsp), %rax
13	  addq	$104, %rsp
14	  ret
```

1.  We can see on line 2 of function eval that it allocates 104 bytes on the stack. Diagram the stack frame for `eval`, showing the values that it stores on the stack prior to calling `process`.
https://dreamanddead.github.io/CSAPP-3e-Solutions/chapter3/3.67/

2. What value does `eval` pass in its call to `process?`
In its call to `process`, `eval` passes the address of a `strA` structure stored on the stack. The value passed in the call to `process` is stored in the register `%rdi` and is calculated as `leaq 64(%rsp), %rdi`, which loads the address of `64(%rsp)` into `%rdi`.

The `strA` structure is constructed on the stack with the values of `x`, `y`, and `z` stored at `%rsp-8`, `%rsp-16`, and `%rsp-24` respectively. The address of `z`, stored at `%rsp-32`, is passed as the value of the `p` member of the `strA` structure.

By passing the address of the `strA` structure, `eval` is able to pass the values of `x`, `y`, `z`, and the address of `z` as arguments to the `process` function. This allows `process` to access and modify the values stored in the `strA` structure and return the modified values in a `strB` structure.

3. How does the code for `process` access the elements of structure arguments?
"process access s by %rsp+offset, not by %rdi" - dream

The code for the `process` function accesses the elements of the `strA` structure argument `s` stored on the stack and not through the `%rdi` register because of the way the `movq` instructions are used in the code.

The `movq` instructions in the code access memory locations on the stack by using the stack pointer register `%rsp` and an offset, such as `24(%rsp)`, which represents the memory location `24` bytes from the current value of the stack pointer. This indicates that the elements of the `strA` structure argument `s` are stored on the stack and not in the `%rdi` register.

For example, the line `movq 24(%rsp), %rdx` loads the value stored at the memory address `24(%rsp)` into the temporary register `%rdx`. This value is the address of the `p` member of the `strA` structure passed as an argument to `process`, and it is stored on the stack. The line `movq (%rdx), %rdx` then loads the value stored at the memory address pointed to by `%rdx` into `%rdx`, which is the value of the `z` variable.

By using memory addresses to access the elements of the structure argument stored on the stack, the code is able to modify the values stored in the structure and return the modified values in a `strB` structure.

<mark style="background: #FFB8EBA6;">4.  How does the code for `process` set the fields of result structure `r?`</mark>

The `eval` function passes the address `%rsp + 64` to the `process` function as the argument for the `strA` structure. The `process` function stores the data for the `strA` structure starting at this address and returns the address when it is done processing.

To understand how the `process` function stores the data for the `strA` structure starting at the memory address passed as an argument, it is necessary to look at the code for the `eval` function, which passes the memory address of the `strA` structure to the `process` function.

Here is the code for the `eval` function:
```c
19	long eval(long x, long y, long z) {
20		strA s;
21		s.a[0] = x;
22		s.a[1] = y;
23		s.p = &z;
24		strB r = process(s);
25		return r.u[0] + r.u[1] + r.q;
26	}
```
1.  The `eval` function takes three long integer arguments `x`, `y`, and `z`.
    
2.  The code creates a `strA` structure `s`.
    
3.  The line `s.a[0] = x;` sets the first element of the `a` array of the `strA` structure `s` to the value of the `x` argument.
    
4.  The line `s.a[1] = y;` sets the second element of the `a` array of the `strA` structure `s` to the value of the `y` argument.
    
5.  The line `s.p = &z;` sets the `p` member of the `strA` structure `s` to the address of the `z` argument.
    
6.  The `process` function is called with the `strA` structure `s` passed as an argument.
    

The `eval` function passes the memory address of the `strA` structure `s` to the `process` function, which stores the data for the `strA` structure starting at this memory address. The `process` function then modifies the data stored in the `strA` structure and returns the modified data in a `strB` structure.

<mark style="background: #FFB8EBA6;">5. Complete your diagram of the stack frame for `eval`, showing how `eval` accesses the elements of structure `r` following the return from process.</mark>

```c
104  +------------------+
     |                  |
     |                  |
     |                  |
     |                  |
     |                  |
     |                  |
 88  +------------------+ <-- z
     |        z         |
 80  +------------------+ <-- x
     |        x         |
 72  +------------------+ <-- y
     |        y         |
 64  +------------------+ <-- %rdi(eval pass in)
     |                  |  \
     |                  |   -- %rax(process pass out)
     |                  |
     |                  |
     |                  |
     |                  |
 32  +------------------+
     |         z        |
 24  +------------------+
     |        &z        |
 16  +------------------+
     |         y        |
  8  +------------------+
     |         x        |
  0  +------------------+ <-- %rsp in eval
     |                  |
 -8  +------------------+ <-- %rsp in process

```
In this diagram, the values of the long integers `x`, `y`, and `z` are shown as being stored on the stack starting at memory addresses `%rsp + 80`, `%rsp + 72`, and `%rsp + 88`, respectively. The memory address of the `strA` structure is stored in the `%rdi` register and passed to the `process` function as an argument. The `process` function then stores the data for the `strA` structure starting at this memory address and returns the address when it is done processing by passing the memory address stored in the `%rax` register back to `eval`. The diagram also shows that the `process` function creates its own stack frame by subtracting 8 bytes from the stack pointer `%rsp`
- - -
```c
strB process(strA s)
1	process:
2	  movq	%rdi, %rax
	  # Move the first argument passed to the function, `s`, from the argument register %rdi to the temporary register %rax
	  # This is done to preserve the original value of %rdi, as it may be needed later. Using a temporary register allows the value to be used without modifying %rdi.

3	  movq	24(%rsp), %rdx
	  # Move the value stored at 24(%rsp) to the temporary register %rdx
	  # This value is likely the address of the member `p` of the `strA` structure passed as an argument to `process`.

4	  movq	(%rdx), %rdx
	  # Load the value stored at the memory address in %rdx into %rdx
	  # This loads the value stored at the address pointed to by `p`, which is `z`.

5	  movq	16(%rsp), %rcx
	  # Move the value stored at 16(%rsp) to the temporary register %rcx
	  # This value is likely the second member of the `strA` structure passed as an argument to `process`.

6	  movq	%rcx, (%rdi)
	  # Move the value in %rcx to the memory address pointed to by %rdi
	  # This stores the second member of the `strA` structure passed as an argument to `process` at the address pointed to by `s`.

7	  movq	8(%rsp), %rcx
	  # Move the value stored at 8(%rsp) to the temporary register %rcx
	  # This value is likely the first member of the `strA` structure passed as an argument to `process`.

8	  movq	%rcx, 8(%rdi)
	  # Move the value in %rcx to the memory address 8 bytes away from the address pointed to by %rdi
	  # This stores the first member of the `strA` structure passed as an argument to `process` at the address 8 bytes away from the address pointed to by `s`.

9	  movq	%rdx, 16(%rdi)
	  # Move the value in %rdx to the memory address 16 bytes away from the address pointed to by %rdi
	  # This stores the value of `z` at the address 16 bytes away from the address pointed to by `s`.

10	  ret
	  # Return from the function

long eval(long x, long y, long z)
x in %rdi, y in %rsi, z in %rdx
1	eval:
2	  subq	$104, %rsp
	  # Subtract 104 from the stack pointer %rsp to allocate 104 bytes of space on the stack
	  # This creates a stack frame for the function and reserves space for local variables and intermediate values.

3	  movq	%rdx, 24(%rsp)
	  # Move the value of `z` from %rdx to the stack at 24(%rsp)
	  # This stores the value of `z` on the stack for later

```
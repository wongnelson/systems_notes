q; how are jump targets written?
a; using labels

q; what generates the proper encodings of the jump targets?
a; the assembler and later the linker

q; what's a *PC relative* encoding for jumps?
a; PC relative encodings are the most common encoding for jumps - they encode the difference between the address of the target instruction  and the address of the instruction immediately following the jump

q; an example of a relative and absolute jump
Relative jump:

`mov %eax, 0x1
jmp 0x10`

In this example, the instruction "jmp 0x10" is a relative jump, the target address is encoded as an offset (0x10) from the current location of the program counter. The target address is calculated by adding the offset (0x10) to the current location of the program counter. This is indicated by the use of an immediate value (0x10) as the operand for the jump instruction.

Absolute jump:

`mov %eax, 0x1 
jmp *0x400000`

In this example, the instruction "jmp *0x400000" is an absolute jump. The target address is encoded as an absolute memory address (0x400000), regardless of the current location of the program counter. The jump instruction will always jump to the same memory location (0x400000), regardless of where the program is currently executing. This is indicated by the use of a memory address (0x400000) as the operand for the jump instruction.

It's important to note that the use of the indirection operator (*) on the memory address is not necessary but it could be used in some cases, as an example when the target address is stored in memory, and the instruction jmp *0x400000 is using the address stored in memory to jump to the instruction.

- - - 
```c
1	  movq	%rdi, %rax
2	  jmp	.L2
3	.L3:
4	  sarq	%rax
5	.L2:
6	  testq	%rax, %rax
7	  jg	.L3
8	  rep; ret
```

The disassembled version of the format generated by the assembler is as follows:


```c
1	0:	48 89 f8	mov	%rdi,%rax
2	3:	eb 03		jmp	8 <loop+0x8>
3	5:	48 d1 f8	sar	%rax
4	8:	48 85 c0	test	%rax,%rax
5	b:	7f f8		jg	5 <loop+0x5>
6	d:	f3 c3		repz retq
```

The program takes a value in the %rdi register, stores it in the %rax register (line 1), and then jumps to the label .L2 (line 2). The program then enters a loop, starting at label .L3 (line 3). Inside the loop, the program shifts the value in the %rax register to the right by one bit (line 4) using the sarq instruction. The program then checks if the value in the %rax register is greater than 0 (line 6) using the testq instruction and the jg instruction (line 7). If the value is greater than 0, the program jumps back to label .L3, otherwise it exits the loop and returns (line 8) using the rep; ret instruction.

q; how is eb 03 is located at memory address 5?
a; The instruction "eb 03" is located at memory address 5 in the disassembled version because that is the location assigned to it by the assembler. The memory addresses are assigned by the assembler in a linear fashion, starting from a specific address, usually 0, and increasing by the size of the instruction.

In this case, the instruction "48 89 f8" is located at memory address 0, it takes 3 bytes of memory so the next instruction starts at memory address 3. Then, the instruction "48 d1 f8" is located at memory address 5 and takes 2 bytes of memory, so the next instruction "48 85 c0" starts at memory address 7.

- Thots - the L2 code starts at memory section 8.


#### 3.15

The je instruction has as its target 0x4003fc + 0x02. As the original disassembled code shows, this is 0x4003fe:


1.  In the following excerpts from a disassembled binary, some of the information has been replaced by X's. Answer the following questions about these instructions.
    
    1.  What is the target of the `je` instruction below? (You do not need to know anything about the `callq` instruction here.)
        
        ```
        
        4003fa: 74 02	je	XXXXXX
        4003fc: ff d0	callq	*%rax
        ```
        
    2.  What is the target of the `je` instruction below?
        
        ```
        
        40042f: 74 f4	je	XXXXXX
        400431: 5d	pop	%rbp
        ```
        
    3.  What is the address of the `ja` and pop instructions?
        
        ```
        
        XXXXXX: 77 02	ja	400547
        XXXXXX: 5d	pop	%rbp
        ```
        
    4.  In the code that follows, the jump target is encoded in PC-relative form as a 4-byte two's-complement number. The bytes are listed from least significant to most, reflecting the little-endian byte ordering of x86-64. What is the address of the jump target?
        
        ```
        
        4005e8: e9 73 ff ff ff	jmpq	XXXXXXX
        4005ed: 90		nop
        ```

a; 
The je instruction has as its target 0x4003fc + 0x02. As the original disassembled code shows, this is 0x4003fe:


4003fa:7402		je	4003fe
4003fc:ffd0		callq	*%rax
The je instruction has as its target 0x0x400431 – 12 (since 0xf4 is the 1-byte two's-complement representation of – 12). As the original disassembled code shows, this is 0x400425:


40042f:74f4		je	400425
400431: 5d		pop	%rbp
According to the annotation produced by the disassembler, the jump target is at absolute address 0x400547. According to the byte encoding, this must be at an address 0x2 bytes beyond that of the pop instruction. Subtracting these gives address 0x400545. Noting that the encoding of the ja instruction requires 2 bytes, it must be located at address 0x400543. These are confirmed by examining the original disassembly:


400543:77 02	ja	400547
400545: 5d	pop	%rbp
Reading the bytes in reverse order, we can see that the target offset is 0xffffff73, or decimal -141. Adding this to 0x0x4005ed (the address of the nop instruction) gives address 0x400560:


4005e8: e9 73 ff ff ff	jmpq	400560
4005ed:90		nop


4003fa:7402		je	?
4003fc:ffd0		callq	*%rax
what should be in place of ?
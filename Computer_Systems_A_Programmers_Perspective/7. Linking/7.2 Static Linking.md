## What are the two main tasks of a static linker?

Static linkers, such as the Linux `ld` (short for 'linker') program, take relocatable object files and command-line arguments as input and generate a fully linked executable object file as output. To build the executable, the linker must perform two main tasks:

1.  **Symbol resolution**: Object files define and reference symbols, which correspond to functions, global variables, or static variables. Symbol resolution associates each symbol reference with exactly one symbol definition.
2.  **Relocation**:<mark style="background: #FFB8EBA6;"> Compilers and assemblers generate code and data sections that start at address 0.</mark> The linker relocates these sections by associating a memory location with each symbol definition and modifying all references to those symbols to point to this memory location. The linker follows detailed instructions called relocation entries, generated by the assembler, to perform these relocations.

<mark style="background: #FFB8EBA6;">pink:</mark>
Compilers and assemblers generate code and data sections that start at address 0 because, at this stage, the actual location of these sections in the final executable or shared object is not yet determined. By setting the starting address to 0, it simplifies the process of generating relocatable object files.

During the linking process, the linker is responsible for determining the final addresses of these code and data sections in memory. It does this by merging the sections from different object files, assigning memory locations, and then updating the symbol references and addresses accordingly. This process is called relocation.

So, starting the code and data sections at address 0 allows the linker to easily calculate the final offsets for the symbols within the sections by adding the determined base address for each section.

## What are the different types of sections in relocatable object files?

Relocatable object files consist of various code and data sections, where each section is a contiguous sequence of bytes. Some of the common types of sections include:

-   Instructions: This section contains the machine code instructions of the program.
-   Initialized global variables: This section holds the values of global variables that are initialized with specific values.
-   Uninitialized variables: This section is reserved for variables that have not been initialized with specific values.

```c
+--------------------------------------+
|         Relocatable Object File      |
+--------------------------------------+
|           Instructions (Code)        |
|--------------------------------------|
| - Machine code instructions          |
| - Function definitions               |
| - Branches and jumps                 |
| - System calls                       |
+--------------------------------------+
|       Initialized Global Variables   |
|--------------------------------------|
| - Global variables with initial values|
|   e.g., int x = 5;                    |
| - Constant values                     |
| - String literals                     |
+--------------------------------------+
|       Uninitialized Variables        |
|--------------------------------------|
| - Global variables without initial   |
|   values, e.g., int y;               |
| - Static variables without initial   |
|   values                             |
| - Memory reserved for variables      |
+--------------------------------------+
```

## How does symbol resolution work in the linking process?
### What is symbol resolution?

Symbol resolution is the process of associating each symbol reference with exactly one symbol definition. Symbols correspond to functions, global variables, or static variables.

### When does symbol resolution occur?

Symbol resolution occurs during the linking process.

### What does the linker do during symbol resolution?

During the linking process, the linker matches references to symbols in the relocatable object files with their corresponding definitions.

## How does relocation work in the linking process?

### What is relocation?

Relocation is the process of assigning memory locations to symbol definitions and modifying references to those symbols to point to the assigned memory locations.

### Why is relocation necessary?

Relocation is necessary because compilers and assemblers generate code and data sections that start at address 0, so the linker must relocate these sections to ensure they are placed at the correct memory addresses during program execution.

### What are relocation entries?

Relocation entries are detailed instructions generated by the assembler that provide information on how to adjust the symbol references in the code and data sections to match the assigned memory locations.

### What role does the linker play in relocation?

The linker follows the relocation entries to perform the relocation process. The linker is responsible for associating a memory location with each symbol definition and modifying all references to those symbols to point to the correct memory location.

## What is the role of compilers and assemblers in generating object files for the linker?

Compilers and assemblers play a crucial role in generating object files that are used by the linker. They are responsible for translating source code into machine code instructions and organizing the code and data sections in a format that can be processed by the linker. Compilers and assemblers generate relocation entries, which provide the linker with instructions on how to adjust symbol references during the relocation process
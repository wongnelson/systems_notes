
## What is the relocation algorithm used by the linker?

The pseudocode below shows the relocation algorithm used by the linker. This algorithm iterates over each section `s` and each relocation entry `r` associated with each section. 

In this context, you can think of each section `s` as an array of bytes and each relocation entry `r` as a struct of type `Elf64_Rela`, as defined in Figure 7.9. When this algorithm runs, the linker has already chosen runtime addresses for each section (denoted `ADDR(s)`) and each symbol (denoted `ADDR(r.symbol)`).

```c
foreach section s {
	foreach relocation entry r {
		refptr = s + r.offset; /* ptr to reference to be relocated */

		/* Relocate a PC-relative reference */
		if (r.type == R_X86_64_PC32) {
			refaddr = ADDR(s) + r.offset; /* ref's run-time address */
			*refptr = (unsigned) (ADDR(r.symbol) + r.addend - refaddr);
		}

		/* Relocate an absolute reference */
		if (r.type == R_X86_64_32)
			*refptr = (unsigned) (ADDR(r.symbol) + r.addend);
	}
}
```

## What is the role of relocation entries in symbol references?

The main function references two global symbols, `array` and `sum`. For each reference, the assembler generates a relocation entry. These relocation entries instruct the linker that the reference to `sum` should be relocated using a 32-bit PC-relative address, and the reference to `array` should be relocated using a 32-bit absolute address.

## How does the linker use the relocation algorithm to relocate references?

Let's see how the linker uses this algorithm to relocate the references in an example program. For instance, consider the disassembled code from `main.o`, generated by the GNU `objdump` tool (`objdump -dx main.o`).

```assembly
0000000000000000 <main>:
0: 4883ec08		sub		$0x8, %rsp
4: be 02 00 00 00	mov		$0x2, %esi
9: bf 00 00 00 00	mov		$0x0, %edi		%edi = &array
	a: R_X86_64_32 array				Relocation entry
e: e8 00 00 00 00	callq		13 <main+0x13>		sum()
	f: R_X86_64_PC32 sum-0x4			Relocation entry
13: 4883c408		add		$0x8, %rsp
17:c3			retq
```

The relocation entries and instructions are actually stored in different sections of the object file. The `objdump` tool displays them together for convenience. The linker uses the relocation entries to identify the type of address (PC-relative or absolute) to be used for each reference and performs the relocation accordingly.

## What is the purpose of the relocation entries in the assembly code?

In the assembly code above, the relocation entries `R_X86_64_32 array` and `R_X86_64_PC32 sum-0x4` tell the linker how to handle the references to the global symbols `array` and `sum`. Specifically, the reference to `sum` is relocated using a 32-bit PC-relative address, and the reference to `array` is relocated using a 32-bit absolute address. These entries are crucial for the linker to correctly merge the object files into an executable.


```toc
```
q: what's a compiler driver?
a; it invokes the language preprocessor, compiler, assembler, and linker, as needed on behalf of the user

q; what does the linker do at a high level?
a; it combines relocatable object files to form an executable object file

q; what's an ASCII intermediate file?
a; An _ASCII file_ is a text _file_ that allows a _document_ to be recognized and read easily by any platform or operating system

q; what are files with the .i extension?
a; C source code that should not be preprocessed
https://stackoverflow.com/questions/25137743/where-do-we-use-i-files-and-how-do-we-generate-them

#### Steps of static linking
- start with a c file - lets call it foo.c
1) run linker - generates the foo.i file 
2) run C compiler to translate foo.i ASCII asm file foo.asm
3) run the assembler to translate main.s into a binary relocatable object file foo.o
4) the linker will do the same for other C files and finally the linker program `ld` combines the -o files

## 7.2 Static Linking
q; ok - so at a high level, what do static linkers do?
a; take as input a collection of relocatable object files and command-line arguments and generate as output a fully linked executable object file that can be loaded and run.

q; what do input relocatable object files consist of?
a; various code and data sections, where each section is a contiguous sequence of bytes

q; what are the three data sections? where is it stored?
a; instructions, initialized global variables, and uninitialized variables are in different sections. It's stored in the program memory area.

q; what are the two steps to build the linker?
a; 
Step 1. Symbol resolution: Symbol resolution is an important step in the linking process because it ensures that each symbol reference in the object files is associated with exactly one symbol definition. This step is necessary because object files can contain references to symbols that are not defined within the same file. The linker must resolve these references by finding the corresponding definition in another object file or in a library. If multiple definitions are found for the same symbol, the linker must choose one definition to use.

Step 2. Relocation: Relocation is the process of assigning actual memory addresses to symbols that have been defined in the object files. The purpose of relocation is to allow the program to run correctly regardless of where it is loaded into memory. This step is necessary because the code and data sections generated by the compiler and assembler are based on virtual addresses that start at address 0. The linker must modify these sections so that they use actual memory addresses that are valid for the target machine.

Relocation entries are generated by the assembler and provide the linker with detailed instructions for modifying the code and data sections. The linker uses these entries to update the references to symbols so that they point to the correct memory location. The result is a single executable file that contains all of the code and data needed to run the program, with all symbol references resolved and all memory addresses correctly assigned.

# 7.3 Object Files

q; what are the three types of object files?
a; relocatable, executable, and shared

q; what's the relocatable object file?
a; A relocatable object file is an object file that contains binary code and data in a form that can be combined with other relocatable object files to create an executable object file. The term "relocatable" refers to the fact that the binary code and data in this type of object file do not have fixed memory addresses and can be relocated to different memory locations during the linking process.

The purpose of a relocatable object file is to provide a modular approach to building an executable. Instead of having a single large file with all the binary code and data, relocatable object files allow multiple smaller files to be combined to create the final executable. This makes it easier to manage large software projects, as different parts of the project can be developed and compiled separately, and then combined during the linking process.

During the linking process, the linker combines the relocatable object files, resolving any references between the files, and assigning memory addresses to the binary code and data. The linker can also perform other tasks, such as adding information to the file headers and updating the symbol table. After the linking process is complete, the resulting file is an executable object file that can be loaded into memory and executed.

q; executable?
a; An executable object file is a file that contains binary code and data in a form that can be loaded into memory and executed. Unlike relocatable object files, the binary code and data in an executable object file have fixed memory addresses and do not need to be relocated during the linking process. This makes an executable object file ready to be run without any additional processing. The binary code and data in an executable object file have fixed memory addresses because the memory locations for the code and data have already been determined and assigned during the linking process.

The purpose of an executable object file is to provide a file that can be directly executed by the operating system. An executable object file contains all the necessary information for the operating system to load the binary code and data into memory, allocate memory for any dynamically allocated data, and execute the code.

An executable object file typically contains information such as the file header, the symbol table, and the relocation table. The file header contains information about the file format, the entry point (the location of the first instruction to be executed), and the size of the code and data sections. The symbol table contains information about the symbols (such as function names and variables) used in the code, and the relocation table contains information about any memory addresses that need to be relocated at runtime.

To create an executable object file, the linker combines one or more relocatable object files, resolves any references between the files, and assigns fixed memory addresses to the binary code and data. The resulting file is an executable object file that can be loaded into memory and executed directly by the operating system.

<mark style="background: #ADCCFFA6;">q; shared?</mark>
a; A shared object file, also known as a dynamically linked library, is a special type of relocatable object file that can be loaded into memory and linked dynamically, either at load time or run time. The term "shared" refers to the fact that multiple programs can share the same code and data, which can reduce memory usage and improve performance.

A shared object file contains binary code and data that can be loaded into memory and linked dynamically at runtime. When a program needs to use the code and data in a shared object file, it loads the file into memory and links to it dynamically. This allows multiple programs to share the same code and data, which can reduce memory usage and improve performance.

The main advantage of using shared object files is that they allow for a more modular approach to software development. Instead of having to include all the code and data for a library in each program that uses the library, the library can be implemented as a shared object file that is loaded and linked dynamically at runtime. This makes it easier to manage large software projects and reduces the memory footprint of the programs that use the library.

To create a shared object file, the compiler and linker are used to compile and link the source code into a relocatable object file. The relocatable object file is then processed by a utility program to create the shared object file. The shared object file can then be used by multiple programs, either by linking to it statically at compile time or by loading and linking to it dynamically at runtime.

<mark style="background: #ADCCFFA6;">q; what's an example of a shared object file?</mark>
a; Suppose you have a collection of functions that perform string manipulation, such as concatenating two strings, finding the length of a string, and so on. You want to create a shared object file from these functions so that multiple programs can use the functions without having to include the code for the functions in each program.

Here's how you could create the shared object file:

1.  Write the source code for the string manipulation functions and save it in a file, for example, "string_functions.c".
    
2.  Compile the source code into an object file using the compiler:
``gcc -c -fPIC string_functions.c``

The "-c" option tells the compiler to compile the source code into an object file, and the "-fPIC" option tells the compiler to generate position-independent code, which is required for creating shared object files.

Link the object file into a relocatable object file using the linker:
``gcc -shared string_functions.o -o libstring_functions.so

The "-shared" option tells the linker to create a shared object file, and the "-o" option specifies the name of the output file, in this case "libstring_functions.so".

4.  The shared object file "libstring_functions.so" can now be used by multiple programs, either by linking to it statically at compile time or by loading and linking to it dynamically at runtime.

In this example, you can see how the compiler and linker are used to create a shared object file from the source code for the string manipulation functions. The shared object file can then be used by multiple programs, allowing the functions to be shared and reducing memory usage and improving performance.

<mark style="background: #ADCCFFA6;">q; what generates relocatable/shared object files?</mark>
a; compilers and assemblers

<mark style="background: #ADCCFFA6;">q; what do linkers generate?</mark>
a; executable object files

- an _object module_ is a sequence of bytes, and an _object file_ is an object module stored on disk in a file. However, we will use these terms interchangeably.

# 7.3 Object Files

![[image-20230211105944809.png]]
ELF relocatable object file

<mark style="background: #ADCCFFA6;">q; what does ELF mean?</mark>
a; 
ELF (Executable and Linkable Format) is a standard file format for executables, object files, and shared libraries in Unix-like operating systems. A ELF relocatable object file is a type of object file that conforms to the ELF standard and contains binary code and data in a form that can be combined with other ELF relocatable object files to create an ELF executable object file.

The binary code and data in an ELF relocatable object file do not have fixed memory addresses and can be relocated to different memory locations during the linking process. ELF relocatable object files are typically used in the development of large software projects, where the code for different components of the project can be compiled into separate relocatable object files and then combined into a single executable object file during the linking process.

ELF relocatable object files typically contain information such as the file header, the symbol table, and the relocation table. The file header contains information about the file format, the size of the code and data sections, and other information needed by the operating system to load the file into memory. The symbol table contains information about the symbols used in the code, and the relocation table contains information about any memory addresses that need to be relocated at runtime.

## ELF structure

q; what's the ELF header?
a; The ELF (Executable and Linkable Format) header is a critical component of an ELF relocatable object file. The header starts with a 16-byte sequence that describes the word size and byte ordering of the system that generated the file. The rest of the header provides information that the linker needs to parse and understand the object file, including the size of the ELF header, the object file type (relocatable, executable, or shared), the target machine type (e.g. x86-64), the file offset of the section header table, the size and number of entries in the section header table, among others.

Between the ELF header and the section header table, the sections of the object file are located. These sections can hold various types of data, such as code, data, symbol table information, and relocation information. The section header table contains a fixed-size entry for each section in the object file, providing information about the location and size of each section. This information is used by the linker when combining the object file with other object files to create an executable file.

q; what are the sections?
a: READ THE BOOK

## 7.5 Relocatable object files

q; what are the three categories of of symbols?
a; global, external and local

### Consider a relocatable object (m)

<mark style="background: #ADCCFFA6;">Global Symbols</mark> - which are defined by module m, can be referenced by other modules. These symbols correspond to non-static C functions and global variables.

Examples:
-   A non-static C function defined in a module, such as `int add(int a, int b)`. This function is defined in a module and can be referenced by other modules, so it is considered a global symbol. The linker will make the function's memory address available to other modules, so that they can call the function.
    
-   A global variable defined in a module, such as `int g_count = 0`. This variable is defined in a module and can be referenced by other modules, so it is considered a global symbol. The linker will make the variable's memory address available to other modules, so that they can read or modify its value.

<mark style="background: #ADCCFFA6;">External symbols </mark>are referenced by module m, but defined by another module. These symbols correspond to non-static C functions and global variables that are defined in other modules.

Examples

-   A non-static C function defined in another module and referenced in a module, such as `extern int subtract(int a, int b)`. This function is referenced in a module, but it is defined in another module, so it is considered an external symbol. The linker will resolve the reference to the function by linking the object file that references the function to the object file that defines the function.
    
-   A global variable defined in another module and referenced in a module, such as `extern int g_total`. This variable is referenced in a module, but it is defined in another module, so it is considered an external symbol. The linker will resolve the reference to the variable by linking the object file that references the variable to the object file that defines the variable.

q: why use `extern`?
a; 
When a function is declared as an external symbol in one module and defined in another module, the compiler generates two separate object files, each containing a portion of the program. During the linking process, the linker combines the two object files into a single executable file.

 The declaration of the subtract function in one module as an external symbol (extern int subtract(int a, int b)) indicates that the definition of the function is located in another module. The linker resolves the reference to the function by linking the object file that references the function to the object file that defines the function.

Code example:

Imagine you have two source code files, `module1.c` and `module2.c`. `module1.c` contains the following code:

```c
#include <stdio.h>

extern int subtract(int a, int b);

int main(void) {
  int result = subtract(5, 3);
  printf("Result: %d\n", result);
  return 0;
}
```
And `module2.c` contains the following code:
```c
int subtract(int a, int b) {
  return a - b;
}
```
In this example, `module1.c` references the `subtract` function, which is defined in `module2.c`. The `extern` keyword in the declaration of `subtract` in `module1.c` tells the compiler that the `subtract` function is defined in another module, and that its memory address will be provided by the linker.

When you compile and link the two source code files, the compiler generates two object files, `module1.o` and `module2.o`. During the linking process, the linker combines the two object files into a single executable file. The linker resolves the reference to the `subtract` function in `module1.o` by linking it to the definition of the `subtract` function in `module2.o`.

In this example, the `subtract` function is considered an external symbol, because it is referenced in `module1.c` but defined in `module2.c`. The linker resolves the reference to the `subtract` function by linking `module1.o` to `module2.o`.

<mark style="background: #ADCCFFA6;">Local symbols </mark>are defined and referenced exclusively within module m. These symbols correspond to static C functions and global variables that are defined with the static attribute. They are only visible within module m and cannot be referenced by other modules.

Example:
-   A static C function defined in a module, such as `static int multiply(int a, int b)`. This function is defined and used only within a single module, so it is considered a local symbol. The linker will not make the function's memory address available to other modules, since the function is not intended to be called from other modules.
    
-   A global variable defined in a module with the `static` attribute, such as `static int g_result = 0`. This variable is defined and used only within a single module, so it is considered a local symbol. The linker will not make the variable's memory address available to other modules, since the variable is not intended to be used by other modules.


<mark style="background: #ADCCFFA6;">Local linker vs local program variables</mark>
The distinction between local linker symbols and local program variables is an important one. Local linker symbols are symbols that are defined and referenced within a single object file, and are not intended to be used by other object files. These symbols include static functions and static global variables.

On the other hand, local program variables are variables that are defined within a function and have a local scope, meaning they can only be used within the function where they are defined. These variables include function parameters and variables declared with the `auto` or `register` keywords.

It's important to realize that local program variables are not part of the symbol table in the `.symtab` section of an object file. The symbol table in `.symtab` only contains information about global and static symbols, not about local program variables. This is because local program variables are managed at run time on the stack, and their memory addresses can change as the program executes. They are not of interest to the linker, which is only concerned with linking global and static symbols.

- - -
q; where does static local procedure variables end up? why?
a; in .data or .bss for each definition and creates a local linker symbol in the symbol table with a unique name. The reason for using `static` variables in C is to persist data between function calls. When a static variable is defined in a function, it is only initialized once, when the program starts. The value of the variable is preserved between function calls, so it retains its value even after the function returns. This can be useful for maintaining state between function calls, or for implementing a counter that needs to persist across multiple function calls.

By allocating space in the data segment for static variables, the compiler ensures that the data persists for the entire lifetime of the program. The linker also creates a unique symbol in the symbol table for each static variable, so that it can be accessed from other parts of the program if necessary.

- - -
```c
1	int f()
2	{
3		static int x = 0;
4		return x;
5	}
6
7	int g()
8	{
9		static int x = 1;
10		return x;
11	}
```
q; there are two static x's. What does the compiler do?
a; the compiler exports a pair of local linker symbols with different names to the assembler. For example, it might use `x.1` for the definition in function `f` and `x.2` for the definition in function `g`.

q; how are symbol tables built?
a; by assemblers, using symbols exported by the compiler into the assembly-language `.s` file

q; where are ELF files contained? why?
a;  in the .symtab section because the ELF format is a standard file format used on many Unix-like systems for executables, object files, and shared libraries. The .symtab section contains information about the symbols defined in the file, such as their names, addresses, and types (e.g., functions, variables).

- - -
```c
1	typedef struct {
2	int	name;		/* String table offset */
3	char	type:4,		/* Function or data (4 bits) */
4		binding:4;	/* Local or global (4 bits) */
5	char	reserved;	/* Unused */
6	short	section;	/* Section header index */
7	long	value;		/* Section offset or absolute address */
8	long	size;		/* Object size in bytes */
9	} Elf64_Symbol;
```
An ELF symbol table is contained in the `.symtab` section. It contains an array of entries
The `Elf64_Symbol` structure contains several fields that provide information about a symbol in an ELF object file. Let's break down each field:

1.  `name`: This is an integer that represents the byte offset into the string table that points to the null-terminated string name of the symbol. The string table is a separate section in the object file that contains all the symbol names used in the file. The `name` field gives the location of the string name in the table, so that the name can be retrieved and used by the linker or runtime linker.
    
2.  `value`: This is the symbol's address. For relocatable modules, the `value` field gives the offset from the beginning of the section where the object is defined. This means that the actual address of the symbol will be determined when the object is linked with other objects to form an executable or shared library. For executable object files, the `value` field gives the absolute run-time address of the symbol, which is the address where the symbol can be found when the program is executed.
    
3.  `size`: This is the size (in bytes) of the object defined by the symbol. For example, if the symbol represents a function, then the `size` field would give the size of the function in bytes.
    
4.  `type`: This field indicates whether the symbol represents a function or data. The `type` field is usually either data or function, although there are other types of symbols as well, such as object or file.

<mark style="background: #ADCCFFA6;">`ABS`, `UNDEF`, and `COMMON` sections do not have entries in the section header table</mark> is because they represent special types of symbols that are not associated with regular sections in the object file.

<mark style="background: #ADCCFFA6;">`ABS`</mark> symbols are absolute symbols that should not be relocated, meaning their address should not be adjusted during linking.

Example:
Consider a global variable `g_counter` in a relocatable object file that should always have the same value, regardless of where it is linked. This symbol can be declared as an `ABS` symbol by using the `ABS` section in the object file.
`int g_counter __attribute((section(".ABS")));

q; what is __attribute((section(".ABS"))); doing
a; The `__attribute((section(".ABS")))` syntax is a GCC (GNU Compiler Collection) extension that allows you to specify the section in which a variable or function should be placed in the object file generated by the compiler. In this case, the `.ABS` section is specified, which is a special section for absolute symbols that should not be relocated.

By placing the symbol in the `.ABS` section, the compiler will ensure that the address of the symbol will not be changed during linking. This is useful when you want to ensure that a symbol has a fixed address, regardless of where it is linked.

In this example, the symbol `g_counter` is placed in the `.ABS` section, ensuring that its address will not be changed during linking. This can be useful, for example, if `g_counter` is used as a global counter that should always have the same value, regardless of where it is linked.

The `__attribute((section(...)))` syntax is specific to GCC and is not part of the standard C or C++ languages. Other compilers may have similar extensions for specifying the section in which a symbol should be placed.

<mark style="background: #ADCCFFA6;">`UNDEF`</mark> symbols are undefined symbols that are referenced in the current object file but defined elsewhere. These symbols will be resolved during linking, when the linker will find the definition of the symbol in another object file or library.

Example:
Consider a function `print_message` that is defined in another object file or library and is used in the current object file. The symbol for `print_message` in the current object file will be declared as an `UNDEF` symbol, and the linker will resolve the symbol by finding its definition in another object file or library.
```c
extern void print_message(const char* message);
...
print_message("Hello, World!");
```

<mark style="background: #ADCCFFA6;">`COMMON`</mark> symbols represent uninitialized data objects that have not yet been allocated. These symbols will be assigned space in the object file's `.bss` section during linking, and their `value` field specifies the required alignment, while their `size` field gives the minimum size.

Example
Consider an uninitialized global variable `g_buffer` that should have a minimum size of 1KB. The symbol for `g_buffer` can be declared as a `COMMON` symbol using the `COMMON` section in the object file.
`char g_buffer[1024] __attribute((section(".COMMON")));`

Since `ABS`, `UNDEF`, and `COMMON` symbols do not correspond to regular sections in the object file, they do not have entries in the section header table, which is used to describe the regular sections in the object file.